<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Han Ma">
  <!-- Open Graph Data -->
  <meta property="og:title" content="网路"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="Haiweya"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://haiweya.github.io"/>
  
    <link rel="alternate" href="/atom.xml" title="Haiweya" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Haiweya</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 5.3.0"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">网路</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Han Ma</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-12-28</span>
            <span class="time">10:11:25</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E7%BD%91%E7%BB%9C/">#网络</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>计算机与计算机之间要有统一的连接标准才能够进行通信，这个标准称之为互联网协议，而网络就是物理链接介质+互联网协议。协议就是一种格式，在现实生活中可以理解为合同，约定。</p>
<a id="more"></a>

<p><a href="https://sm.ms/image/K1kICS6FpzxvsEL" target="_blank"><img src="https://i.loli.net/2020/03/27/K1kICS6FpzxvsEL.png" /></a></p>
<h4 id="1-计算机之间的联通"><a href="#1-计算机之间的联通" class="headerlink" title="1.计算机之间的联通"></a>1.计算机之间的联通</h4><p>A&lt;——&gt;B  两台计算机之间用一根网线连接起来</p>
<p>C 加入之后   A和B都开了一个网口连接C</p>
<p>D加入之后，开网口似乎就不太好使了。想到一个办法，ABCD都和中转机器来进行相连。A告诉中转站这个数据是发送给C的。这就需要信息需要一定的格式。to C from A。后边呀这个中转的东西叫做路由器。</p>
<h4 id="2-计算机和电脑"><a href="#2-计算机和电脑" class="headerlink" title="2.计算机和电脑"></a>2.计算机和电脑</h4><p>计算机包含电脑，冯诺依曼（计算机之父）式计算机：特点：五大组成部分（运算器、控制器、输入、输出、存储器）</p>
<p>图灵（计算机科学之父）,手机和平板也算计算机，WiFi密码就是路由器密码</p>
<p><em>运算器</em>：CPU-&gt;做些逻辑运算 jpu(显卡）—&gt;做些浮点运算</p>
<p><em>存储器</em>：内存（断电数据就没，优点：读写，速度快），硬盘（学名叫辅存，数据持久化，读写速度相对与内存来讲相对与较慢，造价较低，但是容量大，数据持久化）</p>
<p><em>控制器</em>：主板上的一些硬件</p>
<p>注：网口既是输入设备又是输出设备</p>
<h4 id="3-局域网之间的信息通信"><a href="#3-局域网之间的信息通信" class="headerlink" title="3.局域网之间的信息通信"></a>3.局域网之间的信息通信</h4><p>局域网和广域网</p>
<p>局域网之内的互联设备是可以相互访问的，局域网之外的信息是访问不到的。</p>
<p>局域网之间还需要一个路由器进行相连，但是现在还是访问不到，涉及到另外一个东西是IP地址</p>
<p>IP地址分为4个段，XXX.XXX.XXX.XXX 每个段是0~255 之间，分为网络ID和主机ID</p>
<p>A类：网络ID  0-127  0.0.0.0-127.255.255.255（?个网络能有1600+万台）</p>
<p>B类：128.0.0.0-191.255.255</p>
<p>C类：192.0.0.0 - 223.255.255.255</p>
<p>D类：叫做广播或者多播IP</p>
<p>如果想搭建一个服务器能让别人访问到，就必须要有一个公网IP  </p>
<p>域名就是给ip 起的名字</p>
<h4 id="4-域名与dns解析"><a href="#4-域名与dns解析" class="headerlink" title="4.域名与dns解析"></a>4.域名与dns解析</h4><ul>
<li>问：能通过域名直接访问到?台机器吗？</li>
</ul>
<p>答：不可以的。</p>
<ul>
<li><p>当像浏览器的地址栏中输入URL的时候会发生什么？</p>
<ul>
<li><p>（1）看浏览器的缓存，看浏览器认不认识，如果浏览器认识，就直接给你ip然后直接访问。如果不认识，那就浏览电脑的host文件，本机的host是不会缓存的，但是可以自己手动往里边写东西；</p>
</li>
<li><p> （2）看本机host，然后看路由器，访问上级路由，也有可能访问城市的dns服务器</p>
</li>
<li><p> （3）继续向上级的dns服务器找，知道找到gdns全局，gdns一定知道会一层一层的返回回来。浏览器拿到ip地址之后拿到请求的结果。</p>
</li>
</ul>
</li>
<li><p>127.0.0.1  默认指的是自己的这台电脑，127.0.0.0 有的时候代表不知道ip</p>
</li>
</ul>
<h4 id="5-五层网络模型"><a href="#5-五层网络模型" class="headerlink" title="5.五层网络模型"></a>5.五层网络模型</h4><p>应用层   <code>HTTP</code>,<code>dns</code>协议</p>
<p>运输层   <code>tcp</code> ,<code>udp</code> 协议</p>
<p>网络层   IP地址–ip协议</p>
<p>数据链路层  mac地址</p>
<p>物理层用高低电平实数据传输</p>
<p>0  低电平<br>1  高电平</p>
<p>HTTP协议必须伴随着tcp协议 ip协议，简而言之就是HTTP协议是建立在tcp协议之上的。</p>
<p>HTTP包含两个部分<br>一个是请求：request<br>一个是响应：response</p>
<p><code>请求头中都包括：请求方式（get/post） 路径  协议版本</code></p>
<h4 id="6-HTTP协议"><a href="#6-HTTP协议" class="headerlink" title="6.HTTP协议"></a>6.HTTP协议</h4><p>请求request 包含请求头和数据体</p>
<p>请求头：请求方式+ URL+ 协议版本；如：POST /path?a=1&amp;b=2 HTTP1.1 </p>
<p>常用的请求方式get/post 除此之外还有 head 、put 、delete </p>
<p>响应response 包含相应头和数据体</p>
<p>响应头：协议版本 + 状态码 + message </p>
<h4 id="7-get-post-请求的区别"><a href="#7-get-post-请求的区别" class="headerlink" title="7.get/post 请求的区别"></a>7.get/post 请求的区别</h4><p>（1） 是基于什么前提的,如果什么前提都没有,不使用任何规范,只考虑语法和理论上的HTTP协议,那么get和post基本上没有什么区别,只是名字不同;</p>
<p>（2） 如果是基于rfc规范的 </p>
<p>理论上（specification）： get和post是具有相同语法的，但是语义不同，get是用来获取数据的，post是用来发送数据的，其他方面没有区别；</p>
<p>实践上（implementation）：各种浏览器就是这个规范的实现者（实现HTTP协议）。</p>
<p><em>常见的不同</em>：</p>
<ul>
<li><p> get的数据在URL中是可见的，post请求数据是不现实在URL中的。注意的是URL都得展示在地址栏中。</p>
</li>
<li><p>get请求对长度是有限制的，post的长度是无限制的</p>
</li>
<li><p>get请求的数据可以收藏为标签栏，post请求到的数据不能收藏为数据栏</p>
</li>
<li><p>get请求后，按后退，刷新按钮无影响，post数据会被重新提交。</p>
</li>
<li><p>et的编码类型：application/x-www-form-url,post的编码类型很多如：<br>  <code>encodeapplication/x-www-form-urlencoded</code><br>  <code>multipart/form-data</code></p>
</li>
<li><p>get 历史参数会被保留在浏览器中，post不会保存在浏览器中的；</p>
</li>
<li><p>get是允许ASC||.post 没有编码限制，允许发二进制的。</p>
</li>
<li><p>get与post 相比，get安全性较差。因为get所发的数据是URL的一部分并且会保存在浏览器中</p>
</li>
</ul>
<p>get 请求最大的特点是请求的方式都是在URL中（不能传很多数据），发文件需要用post；传大量的数据需要用post ，传输的数据放在数据体中。</p>
<p>HTTP协议是明文传输协议，所以get请求发送很危险，post请求的相对与叫安全的这种说法不可靠。</p>
<h4 id="8-cookie-与-session"><a href="#8-cookie-与-session" class="headerlink" title="8.cookie 与 session"></a>8.cookie 与 session</h4><p>如果用js存储数据的时候，如果关闭掉页面，那么信息就会消失。跨页面保持登陆状态，按正常的HTTP协议来说跨页面保持登陆是实现不了的，因为HTTP协议是上下层无关协议。</p>
<p>网站的保持登陆状态或自动登陆是使用是cookie来实现。</p>
<p>cookie自己只能往自己的域名中种，cookie跨页面，cookie是存储在浏览器（客户端）上，cookie是可以长期存储的，不会因为页面关闭而消失。</p>
<p>所以前端页面上要有持久化可以存储数据的东西，一旦登陆成功就可以存下来的机制才可满足需求。</p>
<p>session 是把登陆信息保存在服务器端，存在session上也有缺点，如果用户量非常大的话，内存会不够用，服务器端会很号资源。假如后端不止一台服务器，专门用一台服务器来存储用户登陆。</p>
<p>百度的登陆步骤：</p>
<ul>
<li><p>未登录</p>
</li>
<li><p>输入用户名和密码</p>
</li>
<li><p>设置cookie ，里面保存着用户的基本信息（加密）；下次访问相关信息的时候就会带上cookie，后端看到有id的cookie就可以解析cookie，并进行解析，给与相应权限。</p>
</li>
</ul>
<p>session 是把登陆信息保存在服务器端，存在session上也有缺点，如果用户量非常大的话，内存会不够用，服务器端会很号资源。假如后端不止一台服务器，专门用一台服务器来存储用户登陆。</p>
<p>因为用户的登陆操作在那台机器上执行的一般就存在哪台机器上。每个服务器有不同的分功，有专门的一台服务器存储用户的登陆信息，通过配置反向代理（轮询、IP哈希），</p>
<p>需要通过反向代理，（轮询、IP哈希）</p>
<p>轮询：挨个给请求，轮询是不太好使，因为轮到谁就需要在谁那儿登陆；</p>
<p>IP哈希：一次打开电脑后IP地址是不会变的，相同的IP地址会打到相同的服务器上，以此来保证你的登陆信息都会是由一台服务器给搞定。 </p>
<p>XSS注入攻击，就是获取cookie</p>
<h4 id="9-页面的正确打开方式"><a href="#9-页面的正确打开方式" class="headerlink" title="9.页面的正确打开方式"></a>9.页面的正确打开方式</h4><p>B/S  和 C/S 结构</p>
<p> c client 客户端  负责内容的展示， s server 服务器端 负责提供内容</p>
<p> b  Brower  负责内容的展示         s server 服务器端 负责提供内容</p>
<p>html页面,页面的本质就是一个带有html结构的字符串，用txt结尾但里面内容为html结构也是可以打开的，文件与后缀没有多大的关系；</p>
<p>服务器端接收到请求后，服务器想要把这个页面内容返回给浏览器，服务器端读取文件，将读取出来的内容返回给浏览器，随后可以看的到相应图片及文字。</p>
<p><em>服务器</em>：</p>
<p>服务器严格的说是一台计算机，这台计算机只提供服务，不是给用户用的。一般是Linux 操作系统</p>
<p>我们经常说的服务器是指服务容器，它是程序。这个程序可以监听端口，看有没有访问者，它可以读取文件并且返回。如果我们想通过服务器的方式来访问我们自己写的页面，我们就得装一个服务容器的程序。</p>
<p> vscode  liveserver   open with liveServer 默认5500 端口</p>
<h4 id="10-发送网络请求"><a href="#10-发送网络请求" class="headerlink" title="10.发送网络请求"></a>10.发送网络请求</h4><p>发出web请求的方式：</p>
<ul>
<li><p>1）浏览器的地址栏中输入一个网址；</p>
</li>
<li><p>2）通过代码发送请求<code>location.href=&#39;https://www.taobao.com/&#39;  </code>可以发送网络请求，但是会发生页面跳转</p>
</li>
<li><p>3）带有src属性的标签    <code>&lt;img src=&quot; https://aecpm.alicdn.com/simba/img/TB1JNHwKFXXXXafXVXXSutbFXXX.jpg&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;</code></p>
</li>
<li><p>4） 带有href 属性的标签  <code>&lt;a rel=&quot;stylesheet&quot; href=&quot;https://aecpm.alicdn.com/simba/img/TB1JNHwKFXXXXafXVXXSutbFXXX.jpg&quot;&gt;hello&lt;/a&gt;</code></p>
</li>
<li><ol start="5">
<li>带有action属性的标签，例如form表单，form表单发出请求之后也会页面跳转。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;https:&#x2F;&#x2F;www.taobao.com&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;label for&#x3D;&quot;id&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name &#x3D;&quot;id&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="6">
<li>ajax 可以用代码控制，页面不会发生跳转，服务器端返回的结果可以继续用代码处理</li>
</ol>
<h4 id="11-跨域访问资源"><a href="#11-跨域访问资源" class="headerlink" title="11. 跨域访问资源"></a>11. 跨域访问资源</h4><p>资源：js文件，但是js文件这种资源是允许被跨域的，static 等（如JPG，png ，MP4 ）都允许被跨域。</p>
<p>或者有这样一种说法：所有的src，href属性请求的资源都可以是被跨域的。</p>
<p>跨域请求的资源：后端接口的数据，其他域的cookie，其他域的缓存</p>
<p>其他的域：</p>
<p><em>怎么样算跨域? 协议、域名、端口号有任意一个不一样就算跨域</em></p>
<p>页面本身：有协议 域名 端口</p>
<h5 id="跨域这个行为，会发生些什么"><a href="#跨域这个行为，会发生些什么" class="headerlink" title="跨域这个行为，会发生些什么?"></a>跨域这个行为，会发生些什么?</h5><ul>
<li><ol>
<li>即使跨了域，请求也可以发出</li>
</ol>
</li>
</ul>
<ul>
<li><p>2）服务器端也是可以接收的</p>
</li>
<li><ol start="3">
<li>服务器端也是可以正常处理的</li>
</ol>
</li>
<li><p>4）服务器端也是正常返回的</p>
</li>
<li><p>5）浏览器也能接收到这些数据</p>
</li>
<li><p>6）接收到之后，发现页面的域和请求的域不同，所以判定为跨域</p>
</li>
<li><ol start="7">
<li>因为浏览器判定为跨域了，不会把结果传递给我们的代码。</li>
</ol>
</li>
</ul>
<h5 id="解决跨域问题："><a href="#解决跨域问题：" class="headerlink" title="解决跨域问题："></a>解决跨域问题：</h5><ul>
<li><p>1） 后端配合我们进行跨域，有一下两种方式<br>  <code>JsonP </code> 正常的情况下返回的数据都是json格式，jsonp是一种特殊的格式</p>
<p>  后端设置属性<code>Access-Control-Allow-Orign</code>属性以支持跨域</p>
</li>
<li><p>2）后端不配合我们进行跨域</p>
<p>  iframe （只能显示，不能控制）</p>
<p>  通过后端代理（自己的后端）</p>
</li>
</ul>
<h4 id="12-用原生js实现ajax"><a href="#12-用原生js实现ajax" class="headerlink" title="12.用原生js实现ajax"></a>12.用原生js实现ajax</h4><pre style="background:#004445">

 // js 实现最简单的ajax 请求,下边的地址其实已经跨域
        var xhl = null;
        if(window.XMLHttpRequest){
            xhl=new XMLHttpRequest();   //通用方式
        }else{
            xhl = new ActiveXObject("Microsoft.XMLHttp");  //兼容ie5的写法
        }

        xhl.open("get","https://developer.duyiedu.com/edu/testAjax");//会发生跨域
        xhl.open("get","https://developer.duyiedu.com/edu/testAjaxCrossOrigin");  //不会发生跨域
        // xhl.open("get","https://developer.duyiedu.com/edu/testJsonp?callBack");  

        xhl.send();


</pre>

<p>xhl.onreadystatechange   当属性readyState 改变时就会执行该函数</p>
<p>xhr.readyState 建立链接之后值为1，发送状态还为1  ，为4 的时候表示请求已完成，已接收导数据，接收到的数据存在xhr.reponseText 中</p>
<p>xhr.status==200 常配合一起验证。status 是状态码，200表示成功。 2XX 成功  3XX表示重定向  4XX 表示客户端的错误 5XX 表示服务端的错误</p>
<p>xhr.open(“get”,”<a target="_blank" rel="noopener" href="https://developer.duyiedu.com/edu/testAjaxCrossOrigin&quot;,true">https://developer.duyiedu.com/edu/testAjaxCrossOrigin&quot;,true</a>);</p>
<p>第三个参数true  or false 可以设定该请求为同步请求或者是为异步请求。</p>
<p>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。串行     false</p>
<p>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。（他发送他的我继续往下走，同时进行）  true 或者 不传</p>
<p>在现实世界中的异步和同步与计算机的世界相反</p>
<p>11.通过jQuery 发送 Ajax jsonp  </p>
<pre style="background:#004445">
    $.ajax({
            url:"https://developer.duyiedu.com/edu/testJsonp",
            type:"post",
            dataType:"jsonp",
            success: function(data){
                console.log(data);
            }
            });
</pre>


<h5 id="jsonp-的格式特殊在哪里？"><a href="#jsonp-的格式特殊在哪里？" class="headerlink" title="jsonp 的格式特殊在哪里？"></a>jsonp 的格式特殊在哪里？</h5><p>发送的时候，会带上一个参数callback，返回的结果不是json格式  而是 callback的名 + json </p>
<p>get类型：</p>
<p>长这样：<code>jQuery311075610012930443_1585205078235(&#123;&quot;status&quot;:&quot;ok&quot;,&quot;msg&quot;:&quot;Hello! There is DuYi education!&quot;&#125;)</code></p>
<p>Request Method: GET  </p>
<p>jsonp 跨域只能使用get方法，如果我们设置的是post方法，jQuery会自动转化为get方法。</p>
<p>不是所有的post都会是get ,jQuery会先判断是否为同源，如果是，是啥就是啥，如果不是同源那就需要替换为post </p>
<h4 id="13-jsonp"><a href="#13-jsonp" class="headerlink" title="13.jsonp"></a>13.jsonp</h4><p>script 标签的src属性可以发出请求   虽然可以引用其他域的资源没有限制，但是浏览器会将返回的文件当做js文件执行</p>
<p> <code>&lt;script src=&quot;https://developer.duyiedu.com/edu/testJsonp?callback= asd&quot;&gt;&lt;/script&gt;</code></p>
<p> <code>asd(callback= asd)</code></p>
<p>接收到的数据会当做js代码用asd函数调用 </p>
<p><em>jsonp 原理</em>：</p>
<ul>
<li>1） 判断请求与当前页面的域是否同源，如果是就发送正常的额Ajax；</li>
<li>2） 如果不是同源 生成一个script标签，</li>
<li>3） 生成一个随机的callback 名字</li>
<li>4） 设置script 标签的src 设置为请求的接口</li>
<li>5） 将callback作为参数拼接在后边</li>
</ul>
<p>===== 前端部分=====</p>
<ul>
<li><p>6） 后端接收到请求后开始准备要返回的数据</p>
</li>
<li><p>7） 后端拼接的数据 ，将要的返回的数据用callback的值和括号包裹起来<br><code>callback= asd </code> 要返回的数据：<code>&#123;&quot;status&quot;:&quot;ok&quot;,&quot;msg&quot;:&quot;Hello! There is DuYi education!&quot;&#125;</code><br>拼接成<code> asd(&#123;&quot;status&quot;:&quot;ok&quot;,&quot;msg&quot;:&quot;Hello! There is DuYi education!&quot;&#125;)</code></p>
</li>
<li><p>8） 将内容返回</p>
</li>
<li><p>9） 浏览器收到数据后会当做js代码来执行</p>
</li>
<li><ol start="10">
<li>从而执行名为asd的方法，这样就收到了请求得到的数据</li>
</ol>
</li>
</ul>
<p>根据jsonp 原理，我们来封装一个Ajax 请求函数</p>
<pre style="background:#004445">
  var $ ={
            ajax:function(options){
                var url = options.url;
                var type = options.type;
                var dataType = options.dataType;
                var targetProtocol =''  ;//目标接口的协议
                var targetHost = '';
                //非同源
                if(url.indexOf('http://')==0 || url.indexOf('https://')==0){
                    var targetUrl = new URL(url);
                    targetProtocol = targetUrl.protocol;
                    targetHost = targetUrl.host;
                }else{
                    // 同源
                    targetProtocol = location.protocol;
                    targetHost= location.host
                }
                if(dataType=="jsonp"){
                    if(location.protocol==targetProtocol && location.host == targetHost ){
                        // dosomething，没跨域做的事情
                    }else{
                        var callback = 'cb'+ Math.floor(Math.random()*1000000);
                        window[callback] = options.success;
                        var script = document.createElement('script');
                        if(url.indexOf('?')>0){
                            script.src= url+ "&callback=" + callback;
                        }else{
                            script.src = url +"?callback=" + callback;
                        }
                        script.id= callback;
                        document.head.appendChild(script);
                    }

                }

            }
        }

        // 调用

        $.ajax({
            url:"https://developer.duyiedu.com/edu/testJsonp",
            type:"post",
            dataType:"jsonp",
            success: function(data){
                console.log(data);
            }
        });


</pre>

<p>结果如下,还是挺好使的</p>
<p><a href="https://sm.ms/image/ZQ9qsCDiU3w4Bdr" target="_blank"><img src="https://i.loli.net/2020/03/27/ZQ9qsCDiU3w4Bdr.png" /></a></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

